using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using GW2MapGetTool;
//
//    var skll = Skll.FromJson(jsonString);

namespace GW2MapGetTool
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Skll
    {
        [JsonProperty("name", Required = Required.Always)]
        public string Name { get; set; }

        [JsonProperty("facts", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Fact[] Facts { get; set; }

        [JsonProperty("description", Required = Required.Always)]
        public string Description { get; set; }

        [JsonProperty("icon", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Uri Icon { get; set; }

        [JsonProperty("type", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SkllType? Type { get; set; }

        [JsonProperty("weapon_type", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DualWield? WeaponType { get; set; }

        [JsonProperty("professions", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Profession[] Professions { get; set; }

        [JsonProperty("slot", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Slot? Slot { get; set; }

        [JsonProperty("flags", Required = Required.Always)]
        public Flag[] Flags { get; set; }

        [JsonProperty("id", Required = Required.Always)]
        public long Id { get; set; }

        [JsonProperty("chat_link", Required = Required.Always)]
        public string ChatLink { get; set; }

        [JsonProperty("traited_facts", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public TraitedFact[] TraitedFacts { get; set; }

        [JsonProperty("categories", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string[] Categories { get; set; }

        [JsonProperty("attunement", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Attunement? Attunement { get; set; }

        [JsonProperty("specialization", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? Specialization { get; set; }

        [JsonProperty("flip_skill", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? FlipSkill { get; set; }

        [JsonProperty("subskills", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Subskill[] Subskills { get; set; }

        [JsonProperty("bundle_skills", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long[] BundleSkills { get; set; }

        [JsonProperty("transform_skills", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long[] TransformSkills { get; set; }

        [JsonProperty("next_chain", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? NextChain { get; set; }

        [JsonProperty("prev_chain", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? PrevChain { get; set; }

        [JsonProperty("toolbelt_skill", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? ToolbeltSkill { get; set; }

        [JsonProperty("cost", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? Cost { get; set; }

        [JsonProperty("dual_wield", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public DualWield? DualWield { get; set; }

        [JsonProperty("initiative", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? Initiative { get; set; }

        [JsonProperty("dual_attunement", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Attunement? DualAttunement { get; set; }
    }

    public partial class Fact
    {
        [JsonProperty("text", Required = Required.Always)]
        public string Text { get; set; }

        [JsonProperty("type", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public FactType? Type { get; set; }

        [JsonProperty("icon", Required = Required.Always)]
        public Uri Icon { get; set; }

        [JsonProperty("value", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Value? Value { get; set; }

        [JsonProperty("hit_count", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? HitCount { get; set; }

        [JsonProperty("dmg_multiplier", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public double? DmgMultiplier { get; set; }

        [JsonProperty("distance", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? Distance { get; set; }

        [JsonProperty("field_type", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public FieldType? FieldType { get; set; }

        [JsonProperty("percent", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public double? Percent { get; set; }

        [JsonProperty("finisher_type", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public FinisherType? FinisherType { get; set; }

        [JsonProperty("duration", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? Duration { get; set; }

        [JsonProperty("status", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Status { get; set; }

        [JsonProperty("description", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("apply_count", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? ApplyCount { get; set; }

        [JsonProperty("target", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Target? Target { get; set; }

        [JsonProperty("prefix", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Prefix Prefix { get; set; }
    }

    public partial class Prefix
    {
        [JsonProperty("text", Required = Required.Always)]
        public Text Text { get; set; }

        [JsonProperty("icon", Required = Required.Always)]
        public Uri Icon { get; set; }

        [JsonProperty("status", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Status { get; set; }

        [JsonProperty("description", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }
    }

    public partial class Subskill
    {
        [JsonProperty("id", Required = Required.Always)]
        public long Id { get; set; }

        [JsonProperty("attunement", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Attunement? Attunement { get; set; }

        [JsonProperty("form", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Form { get; set; }
    }

    public partial class TraitedFact
    {
        [JsonProperty("text", Required = Required.Always)]
        public string Text { get; set; }

        [JsonProperty("type", Required = Required.Always)]
        public FactType Type { get; set; }

        [JsonProperty("icon", Required = Required.Always)]
        public Uri Icon { get; set; }

        [JsonProperty("duration", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? Duration { get; set; }

        [JsonProperty("status", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Status { get; set; }

        [JsonProperty("description", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("apply_count", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? ApplyCount { get; set; }

        [JsonProperty("requires_trait", Required = Required.Always)]
        public long RequiresTrait { get; set; }

        [JsonProperty("overrides", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? Overrides { get; set; }

        [JsonProperty("value", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? Value { get; set; }

        [JsonProperty("distance", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? Distance { get; set; }

        [JsonProperty("prefix", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Prefix Prefix { get; set; }

        [JsonProperty("percent", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? Percent { get; set; }

        [JsonProperty("hit_count", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? HitCount { get; set; }

        [JsonProperty("dmg_multiplier", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public double? DmgMultiplier { get; set; }

        [JsonProperty("target", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Target? Target { get; set; }
    }

    public enum Attunement { Air, Earth, Fire, Water };

    public enum DualWield { Axe, Dagger, Focus, Greatsword, Hammer, Longbow, Mace, None, Nothing, Pistol, Rifle, Scepter, Shield, Shortbow, Spear, Speargun, Staff, Sword, Torch, Trident, Warhorn };

    public enum FieldType { Dark, Ethereal, Fire, Ice, Light, Lightning, Poison, Smoke, Water };

    public enum FinisherType { Blast, Leap, Projectile, Whirl };

    public enum Text { ApplyBuffCondition };

    public enum Target { Healing, None, Power };

    public enum FactType { AttributeAdjust, Buff, ComboField, ComboFinisher, Damage, Distance, Duration, HealingAdjust, NoData, Number, Percent, PrefixedBuff, Radius, Range, Recharge, StunBreak, Time, Unblockable };

    public enum Flag { GroundTargeted, NoUnderwater };

    public enum Profession { Elementalist, Engineer, Guardian, Mesmer, Necromancer, Ranger, Revenant, Thief, Warrior };

    public enum Slot { Downed1, Downed2, Downed3, Downed4, Elite, Heal, Pet, Profession1, Profession2, Profession3, Profession4, Profession5, Toolbelt, Transform1, Utility, Weapon1, Weapon2, Weapon3, Weapon4, Weapon5 };

    public enum SkllType { Bundle, Elite, Heal, Monster, Pet, Profession, Toolbelt, Transform, Utility, Weapon };

    public partial struct Value
    {
        public bool? Bool;
        public double? Double;

        public static implicit operator Value(bool Bool) => new Value { Bool = Bool };
        public static implicit operator Value(double Double) => new Value { Double = Double };
    }

    public partial class Skll
    {
        public static Skll[] FromJson(string json) => JsonConvert.DeserializeObject<Skll[]>(json, GW2MapGetTool.Converter.Settings);
    }

    public static class Serializeto
    {
        public static string ToJson(this Skll[] self) => JsonConvert.SerializeObject(self, GW2MapGetTool.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                AttunementConverter.Singleton,
                DualWieldConverter.Singleton,
                FieldTypeConverter.Singleton,
                FinisherTypeConverter.Singleton,
                TextConverter.Singleton,
                TargetConverter.Singleton,
                FactTypeConverter.Singleton,
                ValueConverter.Singleton,
                FlagConverter.Singleton,
                ProfessionConverter.Singleton,
                SlotConverter.Singleton,
                SkllTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class AttunementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Attunement) || t == typeof(Attunement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Air":
                    return Attunement.Air;
                case "Earth":
                    return Attunement.Earth;
                case "Fire":
                    return Attunement.Fire;
                case "Water":
                    return Attunement.Water;
            }
            throw new Exception("Cannot unmarshal type Attunement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Attunement)untypedValue;
            switch (value)
            {
                case Attunement.Air:
                    serializer.Serialize(writer, "Air");
                    return;
                case Attunement.Earth:
                    serializer.Serialize(writer, "Earth");
                    return;
                case Attunement.Fire:
                    serializer.Serialize(writer, "Fire");
                    return;
                case Attunement.Water:
                    serializer.Serialize(writer, "Water");
                    return;
            }
            throw new Exception("Cannot marshal type Attunement");
        }

        public static readonly AttunementConverter Singleton = new AttunementConverter();
    }

    internal class DualWieldConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DualWield) || t == typeof(DualWield?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Axe":
                    return DualWield.Axe;
                case "Dagger":
                    return DualWield.Dagger;
                case "Focus":
                    return DualWield.Focus;
                case "Greatsword":
                    return DualWield.Greatsword;
                case "Hammer":
                    return DualWield.Hammer;
                case "Longbow":
                    return DualWield.Longbow;
                case "Mace":
                    return DualWield.Mace;
                case "None":
                    return DualWield.None;
                case "Nothing":
                    return DualWield.Nothing;
                case "Pistol":
                    return DualWield.Pistol;
                case "Rifle":
                    return DualWield.Rifle;
                case "Scepter":
                    return DualWield.Scepter;
                case "Shield":
                    return DualWield.Shield;
                case "Shortbow":
                    return DualWield.Shortbow;
                case "Spear":
                    return DualWield.Spear;
                case "Speargun":
                    return DualWield.Speargun;
                case "Staff":
                    return DualWield.Staff;
                case "Sword":
                    return DualWield.Sword;
                case "Torch":
                    return DualWield.Torch;
                case "Trident":
                    return DualWield.Trident;
                case "Warhorn":
                    return DualWield.Warhorn;
            }
            throw new Exception("Cannot unmarshal type DualWield");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DualWield)untypedValue;
            switch (value)
            {
                case DualWield.Axe:
                    serializer.Serialize(writer, "Axe");
                    return;
                case DualWield.Dagger:
                    serializer.Serialize(writer, "Dagger");
                    return;
                case DualWield.Focus:
                    serializer.Serialize(writer, "Focus");
                    return;
                case DualWield.Greatsword:
                    serializer.Serialize(writer, "Greatsword");
                    return;
                case DualWield.Hammer:
                    serializer.Serialize(writer, "Hammer");
                    return;
                case DualWield.Longbow:
                    serializer.Serialize(writer, "Longbow");
                    return;
                case DualWield.Mace:
                    serializer.Serialize(writer, "Mace");
                    return;
                case DualWield.None:
                    serializer.Serialize(writer, "None");
                    return;
                case DualWield.Nothing:
                    serializer.Serialize(writer, "Nothing");
                    return;
                case DualWield.Pistol:
                    serializer.Serialize(writer, "Pistol");
                    return;
                case DualWield.Rifle:
                    serializer.Serialize(writer, "Rifle");
                    return;
                case DualWield.Scepter:
                    serializer.Serialize(writer, "Scepter");
                    return;
                case DualWield.Shield:
                    serializer.Serialize(writer, "Shield");
                    return;
                case DualWield.Shortbow:
                    serializer.Serialize(writer, "Shortbow");
                    return;
                case DualWield.Spear:
                    serializer.Serialize(writer, "Spear");
                    return;
                case DualWield.Speargun:
                    serializer.Serialize(writer, "Speargun");
                    return;
                case DualWield.Staff:
                    serializer.Serialize(writer, "Staff");
                    return;
                case DualWield.Sword:
                    serializer.Serialize(writer, "Sword");
                    return;
                case DualWield.Torch:
                    serializer.Serialize(writer, "Torch");
                    return;
                case DualWield.Trident:
                    serializer.Serialize(writer, "Trident");
                    return;
                case DualWield.Warhorn:
                    serializer.Serialize(writer, "Warhorn");
                    return;
            }
            throw new Exception("Cannot marshal type DualWield");
        }

        public static readonly DualWieldConverter Singleton = new DualWieldConverter();
    }

    internal class FieldTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FieldType) || t == typeof(FieldType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Dark":
                    return FieldType.Dark;
                case "Ethereal":
                    return FieldType.Ethereal;
                case "Fire":
                    return FieldType.Fire;
                case "Ice":
                    return FieldType.Ice;
                case "Light":
                    return FieldType.Light;
                case "Lightning":
                    return FieldType.Lightning;
                case "Poison":
                    return FieldType.Poison;
                case "Smoke":
                    return FieldType.Smoke;
                case "Water":
                    return FieldType.Water;
            }
            throw new Exception("Cannot unmarshal type FieldType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FieldType)untypedValue;
            switch (value)
            {
                case FieldType.Dark:
                    serializer.Serialize(writer, "Dark");
                    return;
                case FieldType.Ethereal:
                    serializer.Serialize(writer, "Ethereal");
                    return;
                case FieldType.Fire:
                    serializer.Serialize(writer, "Fire");
                    return;
                case FieldType.Ice:
                    serializer.Serialize(writer, "Ice");
                    return;
                case FieldType.Light:
                    serializer.Serialize(writer, "Light");
                    return;
                case FieldType.Lightning:
                    serializer.Serialize(writer, "Lightning");
                    return;
                case FieldType.Poison:
                    serializer.Serialize(writer, "Poison");
                    return;
                case FieldType.Smoke:
                    serializer.Serialize(writer, "Smoke");
                    return;
                case FieldType.Water:
                    serializer.Serialize(writer, "Water");
                    return;
            }
            throw new Exception("Cannot marshal type FieldType");
        }

        public static readonly FieldTypeConverter Singleton = new FieldTypeConverter();
    }

    internal class FinisherTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FinisherType) || t == typeof(FinisherType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Blast":
                    return FinisherType.Blast;
                case "Leap":
                    return FinisherType.Leap;
                case "Projectile":
                    return FinisherType.Projectile;
                case "Whirl":
                    return FinisherType.Whirl;
            }
            throw new Exception("Cannot unmarshal type FinisherType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FinisherType)untypedValue;
            switch (value)
            {
                case FinisherType.Blast:
                    serializer.Serialize(writer, "Blast");
                    return;
                case FinisherType.Leap:
                    serializer.Serialize(writer, "Leap");
                    return;
                case FinisherType.Projectile:
                    serializer.Serialize(writer, "Projectile");
                    return;
                case FinisherType.Whirl:
                    serializer.Serialize(writer, "Whirl");
                    return;
            }
            throw new Exception("Cannot marshal type FinisherType");
        }

        public static readonly FinisherTypeConverter Singleton = new FinisherTypeConverter();
    }

    internal class TextConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Text) || t == typeof(Text?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Apply Buff/Condition")
            {
                return Text.ApplyBuffCondition;
            }
            throw new Exception("Cannot unmarshal type Text");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Text)untypedValue;
            if (value == Text.ApplyBuffCondition)
            {
                serializer.Serialize(writer, "Apply Buff/Condition");
                return;
            }
            throw new Exception("Cannot marshal type Text");
        }

        public static readonly TextConverter Singleton = new TextConverter();
    }

    internal class TargetConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Target) || t == typeof(Target?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Healing":
                    return Target.Healing;
                case "None":
                    return Target.None;
                case "Power":
                    return Target.Power;
            }
            throw new Exception("Cannot unmarshal type Target");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Target)untypedValue;
            switch (value)
            {
                case Target.Healing:
                    serializer.Serialize(writer, "Healing");
                    return;
                case Target.None:
                    serializer.Serialize(writer, "None");
                    return;
                case Target.Power:
                    serializer.Serialize(writer, "Power");
                    return;
            }
            throw new Exception("Cannot marshal type Target");
        }

        public static readonly TargetConverter Singleton = new TargetConverter();
    }

    internal class FactTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FactType) || t == typeof(FactType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AttributeAdjust":
                    return FactType.AttributeAdjust;
                case "Buff":
                    return FactType.Buff;
                case "ComboField":
                    return FactType.ComboField;
                case "ComboFinisher":
                    return FactType.ComboFinisher;
                case "Damage":
                    return FactType.Damage;
                case "Distance":
                    return FactType.Distance;
                case "Duration":
                    return FactType.Duration;
                case "HealingAdjust":
                    return FactType.HealingAdjust;
                case "NoData":
                    return FactType.NoData;
                case "Number":
                    return FactType.Number;
                case "Percent":
                    return FactType.Percent;
                case "PrefixedBuff":
                    return FactType.PrefixedBuff;
                case "Radius":
                    return FactType.Radius;
                case "Range":
                    return FactType.Range;
                case "Recharge":
                    return FactType.Recharge;
                case "StunBreak":
                    return FactType.StunBreak;
                case "Time":
                    return FactType.Time;
                case "Unblockable":
                    return FactType.Unblockable;
            }
            throw new Exception("Cannot unmarshal type FactType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FactType)untypedValue;
            switch (value)
            {
                case FactType.AttributeAdjust:
                    serializer.Serialize(writer, "AttributeAdjust");
                    return;
                case FactType.Buff:
                    serializer.Serialize(writer, "Buff");
                    return;
                case FactType.ComboField:
                    serializer.Serialize(writer, "ComboField");
                    return;
                case FactType.ComboFinisher:
                    serializer.Serialize(writer, "ComboFinisher");
                    return;
                case FactType.Damage:
                    serializer.Serialize(writer, "Damage");
                    return;
                case FactType.Distance:
                    serializer.Serialize(writer, "Distance");
                    return;
                case FactType.Duration:
                    serializer.Serialize(writer, "Duration");
                    return;
                case FactType.HealingAdjust:
                    serializer.Serialize(writer, "HealingAdjust");
                    return;
                case FactType.NoData:
                    serializer.Serialize(writer, "NoData");
                    return;
                case FactType.Number:
                    serializer.Serialize(writer, "Number");
                    return;
                case FactType.Percent:
                    serializer.Serialize(writer, "Percent");
                    return;
                case FactType.PrefixedBuff:
                    serializer.Serialize(writer, "PrefixedBuff");
                    return;
                case FactType.Radius:
                    serializer.Serialize(writer, "Radius");
                    return;
                case FactType.Range:
                    serializer.Serialize(writer, "Range");
                    return;
                case FactType.Recharge:
                    serializer.Serialize(writer, "Recharge");
                    return;
                case FactType.StunBreak:
                    serializer.Serialize(writer, "StunBreak");
                    return;
                case FactType.Time:
                    serializer.Serialize(writer, "Time");
                    return;
                case FactType.Unblockable:
                    serializer.Serialize(writer, "Unblockable");
                    return;
            }
            throw new Exception("Cannot marshal type FactType");
        }

        public static readonly FactTypeConverter Singleton = new FactTypeConverter();
    }

    internal class ValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Value) || t == typeof(Value?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Value { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Value { Bool = boolValue };
            }
            throw new Exception("Cannot unmarshal type Value");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Value)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            throw new Exception("Cannot marshal type Value");
        }

        public static readonly ValueConverter Singleton = new ValueConverter();
    }

    internal class FlagConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Flag) || t == typeof(Flag?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "GroundTargeted":
                    return Flag.GroundTargeted;
                case "NoUnderwater":
                    return Flag.NoUnderwater;
            }
            throw new Exception("Cannot unmarshal type Flag");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Flag)untypedValue;
            switch (value)
            {
                case Flag.GroundTargeted:
                    serializer.Serialize(writer, "GroundTargeted");
                    return;
                case Flag.NoUnderwater:
                    serializer.Serialize(writer, "NoUnderwater");
                    return;
            }
            throw new Exception("Cannot marshal type Flag");
        }

        public static readonly FlagConverter Singleton = new FlagConverter();
    }

    internal class ProfessionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Profession) || t == typeof(Profession?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Elementalist":
                    return Profession.Elementalist;
                case "Engineer":
                    return Profession.Engineer;
                case "Guardian":
                    return Profession.Guardian;
                case "Mesmer":
                    return Profession.Mesmer;
                case "Necromancer":
                    return Profession.Necromancer;
                case "Ranger":
                    return Profession.Ranger;
                case "Revenant":
                    return Profession.Revenant;
                case "Thief":
                    return Profession.Thief;
                case "Warrior":
                    return Profession.Warrior;
            }
            throw new Exception("Cannot unmarshal type Profession");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Profession)untypedValue;
            switch (value)
            {
                case Profession.Elementalist:
                    serializer.Serialize(writer, "Elementalist");
                    return;
                case Profession.Engineer:
                    serializer.Serialize(writer, "Engineer");
                    return;
                case Profession.Guardian:
                    serializer.Serialize(writer, "Guardian");
                    return;
                case Profession.Mesmer:
                    serializer.Serialize(writer, "Mesmer");
                    return;
                case Profession.Necromancer:
                    serializer.Serialize(writer, "Necromancer");
                    return;
                case Profession.Ranger:
                    serializer.Serialize(writer, "Ranger");
                    return;
                case Profession.Revenant:
                    serializer.Serialize(writer, "Revenant");
                    return;
                case Profession.Thief:
                    serializer.Serialize(writer, "Thief");
                    return;
                case Profession.Warrior:
                    serializer.Serialize(writer, "Warrior");
                    return;
            }
            throw new Exception("Cannot marshal type Profession");
        }

        public static readonly ProfessionConverter Singleton = new ProfessionConverter();
    }

    internal class SlotConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Slot) || t == typeof(Slot?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Downed_1":
                    return Slot.Downed1;
                case "Downed_2":
                    return Slot.Downed2;
                case "Downed_3":
                    return Slot.Downed3;
                case "Downed_4":
                    return Slot.Downed4;
                case "Elite":
                    return Slot.Elite;
                case "Heal":
                    return Slot.Heal;
                case "Pet":
                    return Slot.Pet;
                case "Profession_1":
                    return Slot.Profession1;
                case "Profession_2":
                    return Slot.Profession2;
                case "Profession_3":
                    return Slot.Profession3;
                case "Profession_4":
                    return Slot.Profession4;
                case "Profession_5":
                    return Slot.Profession5;
                case "Toolbelt":
                    return Slot.Toolbelt;
                case "Transform_1":
                    return Slot.Transform1;
                case "Utility":
                    return Slot.Utility;
                case "Weapon_1":
                    return Slot.Weapon1;
                case "Weapon_2":
                    return Slot.Weapon2;
                case "Weapon_3":
                    return Slot.Weapon3;
                case "Weapon_4":
                    return Slot.Weapon4;
                case "Weapon_5":
                    return Slot.Weapon5;
            }
            throw new Exception("Cannot unmarshal type Slot");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Slot)untypedValue;
            switch (value)
            {
                case Slot.Downed1:
                    serializer.Serialize(writer, "Downed_1");
                    return;
                case Slot.Downed2:
                    serializer.Serialize(writer, "Downed_2");
                    return;
                case Slot.Downed3:
                    serializer.Serialize(writer, "Downed_3");
                    return;
                case Slot.Downed4:
                    serializer.Serialize(writer, "Downed_4");
                    return;
                case Slot.Elite:
                    serializer.Serialize(writer, "Elite");
                    return;
                case Slot.Heal:
                    serializer.Serialize(writer, "Heal");
                    return;
                case Slot.Pet:
                    serializer.Serialize(writer, "Pet");
                    return;
                case Slot.Profession1:
                    serializer.Serialize(writer, "Profession_1");
                    return;
                case Slot.Profession2:
                    serializer.Serialize(writer, "Profession_2");
                    return;
                case Slot.Profession3:
                    serializer.Serialize(writer, "Profession_3");
                    return;
                case Slot.Profession4:
                    serializer.Serialize(writer, "Profession_4");
                    return;
                case Slot.Profession5:
                    serializer.Serialize(writer, "Profession_5");
                    return;
                case Slot.Toolbelt:
                    serializer.Serialize(writer, "Toolbelt");
                    return;
                case Slot.Transform1:
                    serializer.Serialize(writer, "Transform_1");
                    return;
                case Slot.Utility:
                    serializer.Serialize(writer, "Utility");
                    return;
                case Slot.Weapon1:
                    serializer.Serialize(writer, "Weapon_1");
                    return;
                case Slot.Weapon2:
                    serializer.Serialize(writer, "Weapon_2");
                    return;
                case Slot.Weapon3:
                    serializer.Serialize(writer, "Weapon_3");
                    return;
                case Slot.Weapon4:
                    serializer.Serialize(writer, "Weapon_4");
                    return;
                case Slot.Weapon5:
                    serializer.Serialize(writer, "Weapon_5");
                    return;
            }
            throw new Exception("Cannot marshal type Slot");
        }

        public static readonly SlotConverter Singleton = new SlotConverter();
    }

    internal class SkllTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SkllType) || t == typeof(SkllType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Bundle":
                    return SkllType.Bundle;
                case "Elite":
                    return SkllType.Elite;
                case "Heal":
                    return SkllType.Heal;
                case "Monster":
                    return SkllType.Monster;
                case "Pet":
                    return SkllType.Pet;
                case "Profession":
                    return SkllType.Profession;
                case "Toolbelt":
                    return SkllType.Toolbelt;
                case "Transform":
                    return SkllType.Transform;
                case "Utility":
                    return SkllType.Utility;
                case "Weapon":
                    return SkllType.Weapon;
            }
            throw new Exception("Cannot unmarshal type SkllType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SkllType)untypedValue;
            switch (value)
            {
                case SkllType.Bundle:
                    serializer.Serialize(writer, "Bundle");
                    return;
                case SkllType.Elite:
                    serializer.Serialize(writer, "Elite");
                    return;
                case SkllType.Heal:
                    serializer.Serialize(writer, "Heal");
                    return;
                case SkllType.Monster:
                    serializer.Serialize(writer, "Monster");
                    return;
                case SkllType.Pet:
                    serializer.Serialize(writer, "Pet");
                    return;
                case SkllType.Profession:
                    serializer.Serialize(writer, "Profession");
                    return;
                case SkllType.Toolbelt:
                    serializer.Serialize(writer, "Toolbelt");
                    return;
                case SkllType.Transform:
                    serializer.Serialize(writer, "Transform");
                    return;
                case SkllType.Utility:
                    serializer.Serialize(writer, "Utility");
                    return;
                case SkllType.Weapon:
                    serializer.Serialize(writer, "Weapon");
                    return;
            }
            throw new Exception("Cannot marshal type SkllType");
        }

        public static readonly SkllTypeConverter Singleton = new SkllTypeConverter();
    }
}




